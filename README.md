# zAssignment

LIBRARIES USED:
. ArduinoSTL to access vectors for memory rememberance purposes.
. vector which allows you to use the vectors. 
. NewPing allows you to interact with the ultrasonic sensor and use the ping() function to detect objects for task 4.
. ZumoShield which gives you access to the ZumoMotors class that controls 2 motors which assist in changing the speed and direction of the   zumo. ZumoReflectanceSensorArray class used to detect reflectiveness of the surface. This helps in detecting corridors and walls for the assignment.
. Wire library allows data to be sent between Arduino and Genuino boards via the serial data pin.
. Used the g4p library in the Processing IDE which was created Peter Lager. This libraray helps construct the G.U.I, including the   speed slider button and other graphical componenets for the assignment.

SHAREABLE LINK: https://drive.google.com/open?id=1Pf50drZMnH-_feboH_tiKK19gwCd1CrD

Strategies:

For TASK 1 I firstly set up the XBEE communication using XCTU software. Then I used the g4p library in processing to make the forward,back left, right stop buttons. Then I was confused on how to make it work with the arduino. So I used the Physcial Pixel library which was in the arduino IDE under the communication example which had processing code with it. This had the corresponding processing IDE code. I reversed engineered how the port writing worked so when a button was clicked the arduino would listen for the incoming byte from the serial monitor (which was using the XBEES for communication) and using the Zumo Motors class  I changed the speed and direction depending on which button was clicked. There were no major problems during this task apart from not forgetting to flip the XBEE shield on when debugging!

For TASK2 I used the ZumoShield and under that the LineFollower example. Here I learned how the calibration works by intialising the reflectance sensor. After that I used the reflectance sensor documentation via https://www.pololu.com/docs/0J19/all . This also contained information on how the sensors worked in respect to what the sensors measured and how to check for different reflectiveness. This allowed me to move away from the walls due to knowing where the sensors were located (6 of them). The problems here were I had to work out how the reflective sensor threshold worked and reading through the documentation helped with that. A lot of testing was done for when the sensors had to detect the wall using a various combination of OR and AND statements. This worked well but didn't work properly with corners so I used an AND statement that used the left most and right most sensor to detect a threshold value >500. This meant a corner of the wall was reached. This helped to perfect TASK 2.

For TASK 3 returning manual control after automation was difficult. I decided to use booleans for wall detection, so when the wall was hit the boolean toggled to true and gave control to the manual function. This part was straight forward. What became difficult was giving control back to the zumo. After numerous tries the solution was to use a boolean inside the manual function that set the wall detection toggle off and so restarted the whole automation journey until the boolean became true.

For TASK 4 I used the NewPing library and the NewPing example. I manipulated the ping() function which sent out an ultrasonic sound which detected objects.This returned an integer where if the value was bigger than zero an object was detected. Here I had major problem because when I used the code in my work over the XBEE it wasn't working correctly. After many attempts the problem was that the reflectance sensor was intialising a pin in my calibration that was conflicting with the echo pin on th ultrasonic sensor. This kept on giving me a zero i.e there is no object when there actually was. I changed the code by looking at the documentation via 
pololu website which is where they said you can pass the pins via the ZumoReflectance SensorArray constructor instead of using hte .init() function of the class. Removing the .init() function made the ultrasonic sensor work.

For Task 5 I had to think how to save the movement of the zumo. I decided that saving the delays of the forward function during automation was the key to success. Then the problem was that I had to count up until a point otherwise the zumo would just carrying on going forward. The solution was tho save the delay in a counter during wall detetcion and save the total delay when a wall is hit . Here I used the stl::vector library to save the total delay. Next I knew that the delay had to subtract the back delay and the stop delay from the total delay, otherwise the zumo would travel too far. Next the problem was how to get the data and make the zumo follow the distance of the last corridor. So the solution was to use the size of the vector and decrement (in 45 miliseconds which was how long the zumo moved forward for until a wall is hit). In this loop as the 45milisec decremented from the total delay of the last corridor until it reached 0 I made the zumo side detect so it didn't cross black lines(corridors). This still didn't work and after again many more attempts I realised that the zumo had to stop after that command otherwise the zumo would keep moving forward as that was the last command. Setting the motors to stop made task 5 work.

For TASK 6 I had to save turns so I implemented a corrdior right and corridor left button. Both of these were in a character array that stored the character when the button is clicked. Then i used a loop which checked for each corridor (corridors.size()-1 is last and first corridor is corridors.size()-4). Then for each of the corridors position I got their respective turn ie. corrdiorTurn.size()-1 gives me the turn for the last corridor which is negated for the return journey. Then I used the code for TASK 5 which gives me the last corridor ( a side of t-junction) then I changed the code to give me the last 4 times it took for the zumo to hit a wall as there were 4 corridors in the assignment. Then in the loops for each of those corridors I added side wall detection and the turns for those corridors were immediatley written outisde after the loops were executed. The problems I faced during this part was I could not get the zumo to turn back into the rooms . The reason for this was because I did not have enough time and I could not think hard enough unfortunately. If I had enough time I would count the delays it takes until it reaches the rooms. When it reaches the room have a button that stored the direction and the delay (using vectors). Then call these in reverse order. 
